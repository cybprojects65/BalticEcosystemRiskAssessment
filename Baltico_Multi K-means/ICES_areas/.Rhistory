# Fechar o arquivo netCDF
nc_close(nc_data)
library(ncdf4)
# Fechar o arquivo netCDF
nc_close(nc_data)
path <- "C:/Users/laura/Documents/Baltic Sea_Geomar/Copernicus data/Physical Copernicus"
file <- "BAL-MYP-NEMO_PHY-AnnualMeans-2020.nc"
nc_file <- nc_open(file.path(path, file))
# ESTRAZIONE COMPONENTE V DI FONDO
# Carica le librerie necessarie
library(ncdf4)
library(raster)
path <- "C:/Users/laura/Documents/Baltic Sea_Geomar/Copernicus data/Physical Copernicus"
file <- "BAL-MYP-NEMO_PHY-AnnualMeans-2020.nc"
nc_file <- nc_open(file.path(path, file))
# Leggi le variabili necessarie
vo_data <- ncvar_get(nc_file, "vo")    # componente northward della velocità
lat <- ncvar_get(nc_file, "lat")       # latitudine
lon <- ncvar_get(nc_file, "lon")       # longitudine
depth <- ncvar_get(nc_file, "depth")
time_index <- 1
if(length(dim(vo_data)) == 4) {
vo_slice <- vo_data[time_index, , , ]  # [time, depth, lat, lon]
} else {
vo_slice <- vo_data  # se hai già fatto la media o hai un solo timestep
}
find_bottom_vo <- function(vo_array) {
# Inizializza la matrice di output
bottom_vo <- array(NA, dim = c(dim(vo_array)[2], dim(vo_array)[3]))  # [lat, lon]
bottom_depth_index <- array(NA, dim = c(dim(vo_array)[2], dim(vo_array)[3]))
# Cicla attraverso ogni punto lat/lon
for (i in 1:dim(vo_array)[2]) {  # latitudine
for (j in 1:dim(vo_array)[3]) {  # longitudine
# Estrai il profilo verticale VO per questo punto [depth]
vo_profile <- vo_array[, i, j]
# Trova l'ultimo valore non-NA (dal fondo verso l'alto)
# Escludiamo anche i valori di _FillValue (-999)
valid_depths <- which(!is.na(vo_profile) & vo_profile != -999)
if (length(valid_depths) > 0) {
# Prendi l'ultimo indice valido (più profondo)
deepest_index <- max(valid_depths)
bottom_vo[i, j] <- vo_profile[deepest_index]
bottom_depth_index[i, j] <- deepest_index
# Debug: mostra progresso ogni 100 punti
if ((i-1) * dim(vo_array)[3] + j %% 100 == 0) {
cat("Processato punto:", i, j, "- Profondità:", deepest_index,
"- Valore VO:", vo_profile[deepest_index], "\n")
}
}
}
}
return(list(values = bottom_vo, depth_indices = bottom_depth_index))
}
depth_indices
# Trova i valori di fondo per VO
cat("Inizio estrazione componente VO di fondo...\n")
bottom_vo_result <- find_bottom_vo(vo_slice)
bottom_vo_values <- bottom_vo_result$values
# Chiudi il file NetCDF
nc_close(nc_file)
# Crea il raster per la componente VO
vo_raster <- raster(extent(range(lon), range(lat)),
nrows = length(lat),
ncols = length(lon))
# Assegna i valori al raster (NO trasposizione perché è già [lat, lon])
values(vo_raster) <- as.vector(bottom_vo_values)
dim(bottom_vo_values)
length(lat)
# Assegna i valori al raster (NO trasposizione perché è già [lat, lon])
values(vo_raster) <- as.vector(bottom_vo_values)
values(vo_raster) <- as.vector(t(bottom_vo_values))
length(lon)
dim(vo_data)
# Carica le librerie necessarie
library(ncdf4)
library(raster)
library(sp)
path <- "C:/Users/laura/Documents/Baltic Sea_Geomar/Copernicus data/Physical Copernicus"
file <- "BAL-MYP-NEMO_PHY-AnnualMeans-2020.nc"
nc_file <- nc_open(file.path(path, file))
# Leggi le variabili necessarie
vo_data <- ncvar_get(nc_file, "vo")    # componente northward della velocità [time, depth, lat, lon]
lat <- ncvar_get(nc_file, "lat")       # latitudine (length 774)
lon <- ncvar_get(nc_file, "lon")       # longitudine (length 763)
depth <- ncvar_get(nc_file, "depth")   # profondità (length 56)
# Scegli il timestep da estrarre (qui il primo)
time_index <- 1
# Estrai il dato per il tempo specificato
# vo_slice ha dimensioni [depth, lat, lon]
vo_slice <- vo_data[time_index, , , ]
dim(vo_data)
# Estrai il dato per il tempo specificato
# vo_slice ha dimensioni [depth, lat, lon]
vo_data_perm <- aperm(vo_data, c(3, 2, 1))  # depth, lat, lon
vo_slice <- vo_data_perm
# Funzione per trovare la componente VO di fondo
find_bottom_vo <- function(vo_array) {
# vo_array: [depth, lat, lon]
bottom_vo <- matrix(NA, nrow = dim(vo_array)[2], ncol = dim(vo_array)[3])  # [lat, lon]
for (i in 1:dim(vo_array)[2]) {       # latitudine
for (j in 1:dim(vo_array)[3]) {     # longitudine
vo_profile <- vo_array[, i, j]    # profilo verticale
valid_depths <- which(!is.na(vo_profile) & vo_profile != -999)
if (length(valid_depths) > 0) {
deepest_index <- max(valid_depths)
bottom_vo[i, j] <- vo_profile[deepest_index]
}
}
}
return(bottom_vo)
}
bottom_vo_values <- find_bottom_vo(vo_slice)
# Chiudi il file NetCDF
nc_close(nc_file)
# Crea il raster: attenzione a nrows = length(lat), ncols = length(lon)
vo_raster <- raster(extent(range(lon), range(lat)),
nrows = length(lat),
ncols = length(lon))
# Assegna i valori trasposti per rispettare l'orientamento raster
values(vo_raster) <- as.vector(t(bottom_vo_values))
# Imposta il sistema di coordinate geografiche
projection(vo_raster) <- CRS("+proj=longlat +datum=WGS84")
# Esporta il raster in formato ASCII
writeRaster(vo_raster, "bottom_vo_velocity.asc", format = "ascii", overwrite = TRUE)
# 1. Crea il raster originale con la dimensione di lon/lat
vo_raster <- raster(extent(range(lon)), extent(range(lat)),
nrows = length(lat), ncols = length(lon),
crs = CRS("+proj=longlat +datum=WGS84"))
# 2. Assegna i valori
values(vo_raster) <- as.vector(t(bottom_vo_values))  # trasposizione per allineare dimensioni
# Definisci estensione corretta
ext <- extent(min(lon), max(lon), min(lat), max(lat))
# Crea raster con risoluzione 0.1°
vo_raster_0.1 <- raster(extent = ext, res = 0.1, crs = CRS("+proj=longlat +datum=WGS84"))
# Risampiona
vo_raster_resampled <- resample(vo_raster, vo_raster_0.1, method = "bilinear")
dim(vo_data)
path <- "C:/Users/laura/Documents/Baltic Sea_Geomar/Copernicus data/Physical Copernicus"
file <- "BAL-MYP-NEMO_PHY-AnnualMeans-2020.nc"
nc_file <- nc_open(file.path(path, file))
# Leggi le variabili
vo_data <- ncvar_get(nc_file, "vo")    # dimensioni: lon x lat x depth
lat <- ncvar_get(nc_file, "lat")       # length 774
lon <- ncvar_get(nc_file, "lon")       # length 763
depth <- ncvar_get(nc_file, "depth")   # length 56
# Funzione per estrarre il valore più profondo valido di VO a ogni lat/lon
find_bottom_vo <- function(vo_array) {
dims <- dim(vo_array)  # [lon, lat, depth]
bottom_vo <- matrix(NA, nrow = dims[2], ncol = dims[1])  # [lat, lon] output, attenzione all'ordine
bottom_depth_index <- matrix(NA, nrow = dims[2], ncol = dims[1])
for (i in 1:dims[1]) {    # lon
for (j in 1:dims[2]) {  # lat
vo_profile <- vo_array[i, j, ]
valid_depths <- which(!is.na(vo_profile) & vo_profile != -999)
if (length(valid_depths) > 0) {
deepest_index <- max(valid_depths)
bottom_vo[j, i] <- vo_profile[deepest_index]      # nota l'inversione per lat/lon
bottom_depth_index[j, i] <- deepest_index
}
}
}
return(list(values = bottom_vo, depth_indices = bottom_depth_index))
}
cat("Inizio estrazione componente VO di fondo...\n")
bottom_vo_result <- find_bottom_vo(vo_data)
bottom_vo_values <- bottom_vo_result$values  # matrice [lat, lon]
# Chiudi il file NetCDF
nc_close(nc_file)
# Crea estensione corretta
ext <- extent(min(lon), max(lon), min(lat), max(lat))
# Crea raster originale con dimensioni corrette (rows=lat, cols=lon)
vo_raster <- raster(ext, nrows = length(lat), ncols = length(lon), crs = CRS("+proj=longlat +datum=WGS84"))
# Assegna i valori trasponendo (matrice è [lat, lon], raster aspetta vettore colonna per colonna)
values(vo_raster) <- as.vector(t(bottom_vo_values))
# Crea raster con risoluzione 0.1°
vo_raster_0.1 <- raster(ext, res = 0.1, crs = CRS("+proj=longlat +datum=WGS84"))
# Risampiona
vo_raster_resampled <- resample(vo_raster, vo_raster_0.1, method = "bilinear")
# Esporta in ASCII
writeRaster(vo_raster_resampled, "bottom_vo_velocity_0.1deg.asc", format = "ascii", overwrite = TRUE)
getwd()
path <- "C:/Users/laura/Documents/Baltic Sea_Geomar/Copernicus data/Physical Copernicus"
file <- "BAL-MYP-NEMO_PHY-AnnualMeans-2020.nc"
nc_file <- nc_open(file.path(path, file))
# Leggi le variabili
vo_data <- ncvar_get(nc_file, "vo")    # dimensioni: lon x lat x depth
lat <- ncvar_get(nc_file, "lat")       # length 774
lon <- ncvar_get(nc_file, "lon")       # length 763
depth <- ncvar_get(nc_file, "depth")   # length 56
# Funzione per estrarre il valore più profondo valido di VO a ogni lat/lon
find_bottom_vo <- function(vo_array) {
dims <- dim(vo_array)  # [lon, lat, depth]
bottom_vo <- matrix(NA, nrow = dims[2], ncol = dims[1])  # [lat, lon] output, attenzione all'ordine
bottom_depth_index <- matrix(NA, nrow = dims[2], ncol = dims[1])
for (i in 1:dims[1]) {    # lon
for (j in 1:dims[2]) {  # lat
vo_profile <- vo_array[i, j, ]
valid_depths <- which(!is.na(vo_profile) & vo_profile != -999)
if (length(valid_depths) > 0) {
deepest_index <- max(valid_depths)
bottom_vo[j, i] <- vo_profile[deepest_index]      # nota l'inversione per lat/lon
bottom_depth_index[j, i] <- deepest_index
}
}
}
return(list(values = bottom_vo, depth_indices = bottom_depth_index))
}
cat("Inizio estrazione componente VO di fondo...\n")
bottom_vo_result <- find_bottom_vo(vo_data)
bottom_vo_values <- bottom_vo_result$values  # matrice [lat, lon]
# Chiudi il file NetCDF
nc_close(nc_file)
# Crea estensione corretta
ext <- extent(min(lon), max(lon), min(lat), max(lat))
# Crea raster originale con dimensioni corrette (rows=lat, cols=lon)
vo_raster <- raster(ext, nrows = length(lat), ncols = length(lon), crs = CRS("+proj=longlat +datum=WGS84"))
# Assegna i valori trasponendo (matrice è [lat, lon], raster aspetta vettore colonna per colonna)
bottom_vo_values_flipped <- bottom_vo_values[nrow(bottom_vo_values):1, ]
values(vo_raster) <- as.vector(t(bottom_vo_values_flipped))
# Crea raster con risoluzione 0.1°
vo_raster_0.1 <- raster(ext, res = 0.1, crs = CRS("+proj=longlat +datum=WGS84"))
# Risampiona
vo_raster_resampled <- resample(vo_raster, vo_raster_0.1, method = "bilinear")
# Esporta in ASCII
writeRaster(vo_raster_resampled, "bottom_vo_velocity_0.1deg.asc", format = "ascii", overwrite = TRUE)
# Carica le librerie necessarie
library(ncdf4)
library(raster)
library(sp)
path <- "C:/Users/laura/Documents/Baltic Sea_Geomar/Copernicus data/Physical Copernicus"
file <- "BAL-MYP-NEMO_PHY-AnnualMeans-2020.nc"
nc_file <- nc_open(file.path(path, file))
# Leggi le variabili
vo_data <- ncvar_get(nc_file, "vo")    # dimensioni: lon x lat x depth
lat <- ncvar_get(nc_file, "lat")       # length 774
lon <- ncvar_get(nc_file, "lon")       # length 763
depth <- ncvar_get(nc_file, "depth")   # length 56
# Funzione per estrarre il valore più profondo valido di VO a ogni lat/lon
find_bottom_vo <- function(vo_array) {
dims <- dim(vo_array)  # [lon, lat, depth]
bottom_vo <- matrix(NA, nrow = dims[2], ncol = dims[1])  # [lat, lon] output, attenzione all'ordine
bottom_depth_index <- matrix(NA, nrow = dims[2], ncol = dims[1])
for (i in 1:dims[1]) {    # lon
for (j in 1:dims[2]) {  # lat
vo_profile <- vo_array[i, j, ]
valid_depths <- which(!is.na(vo_profile) & vo_profile != -999)
if (length(valid_depths) > 0) {
deepest_index <- max(valid_depths)
bottom_vo[j, i] <- vo_profile[deepest_index]      # nota l'inversione per lat/lon
bottom_depth_index[j, i] <- deepest_index
}
}
}
return(list(values = bottom_vo, depth_indices = bottom_depth_index))
}
cat("Inizio estrazione componente VO di fondo...\n")
bottom_vo_result <- find_bottom_vo(vo_data)
bottom_vo_values <- bottom_vo_result$values  # matrice [lat, lon]
# Chiudi il file NetCDF
nc_close(nc_file)
# Crea estensione corretta
ext <- extent(min(lon), max(lon), min(lat), max(lat))
# Crea raster originale con dimensioni corrette (rows=lat, cols=lon)
vo_raster <- raster(ext, nrows = length(lat), ncols = length(lon), crs = CRS("+proj=longlat +datum=WGS84"))
# Assegna i valori trasponendo (matrice è [lat, lon], raster aspetta vettore colonna per colonna)
bottom_vo_values_flipped <- bottom_vo_values[nrow(bottom_vo_values):1, ]
values(vo_raster) <- as.vector(t(bottom_vo_values_flipped))
# Crea raster con risoluzione 0.1°
vo_raster_0.1 <- raster(ext, res = 0.03, crs = CRS("+proj=longlat +datum=WGS84"))
# Risampiona
vo_raster_resampled <- resample(vo_raster, vo_raster_0.1, method = "bilinear")
# Esporta in ASCII
writeRaster(vo_raster_resampled, "bottom_vo_velocity_0.1deg.asc", format = "ascii", overwrite = TRUE)
41-10%
4+0
41/100*10
657/7
10^0.38
getwd()
library(sf)
setwd("~/Baltic Sea_Geomar/D4Science/Baltic_Sea_qgis_2020/ICES_areas")
# Percorso del file .shp (assicurati che ci siano anche .dbf, .shx, ecc. nella stessa cartella)
shp <- st_read("ICES_Areas_20160601_cut_dense_3857.shp")
# Vedi le prime righe della tabella attributi
head(shp)
# Vedi la struttura dei campi (nomi e tipi di dato)
str(shp)
# Visualizza solo i nomi delle colonne
names(shp)
# Vedi il sistema di coordinate
st_crs(shp)
library(dplyr)
# 1. Leggi lo shapefile
shp <- st_read("ICES_Areas_20160601_cut_dense_3857.shp")
# 2. Filtra solo le zone desiderate
baltic_mask <- shp %>%
filter(SubDivisio %in% c("21", "22", "23", "24", "25"))
# 3. Salva come nuovo shapefile (maschera)
st_write(baltic_mask, "baltic_mask_21_25.shp")
baltic_mask2 <- shp %>%
filter(SubDivisio %in% c("21", "22", "23", "24", "25", "26"))
# 3. Salva come nuovo shapefile (maschera)
st_write(baltic_mask2, "baltic_mask_21_26.shp")
baltic_mask3 <- shp %>%
filter(SubDivisio %in% c("21", "22", "23", "24", "25", "26", "27"))
# 3. Salva come nuovo shapefile (maschera)
st_write(baltic_mask2, "baltic_mask_21_27.shp")
baltic_mask3 <- shp %>%
filter(SubDivisio %in% c("21", "22", "23", "24", "25", "26", "27", "28"))
# 3. Salva come nuovo shapefile (maschera)
st_write(baltic_mask3, "baltic_mask_21_28.shp")
baltic_mask3 <- shp %>%
filter(SubDivisio %in% c("21", "22", "23", "24", "25", "26", "27"))
# 3. Salva come nuovo shapefile (maschera)
st_write(baltic_mask3, "baltic_mask_21_27.shp")
baltic_mask4 <- shp %>%
filter(SubDivisio %in% c("21", "22", "23", "24", "25", "26", "27"))
# 3. Salva come nuovo shapefile (maschera)
st_write(baltic_mask4, "baltic_mask_21_27.shp")
baltic_mask5 <- shp %>%
filter(SubDivisio %in% c("21", "22", "23", "24", "25", "26", "28"))
# 3. Salva come nuovo shapefile (maschera)
st_write(baltic_mask5, "baltic_mask_21_26_28.shp")
library(sf)
# Percorso del file .shp (assicurati che ci siano anche .dbf, .shx, ecc. nella stessa cartella)
shp <- st_read("ICES_Areas_20160601_cut_dense_3857.shp")
# Vedi le prime righe della tabella attributi
head(shp)
# Vedi il sistema di coordinate
st_crs(shp)
library(dplyr)
# 2. Filtra solo le zone desiderate
baltic_mask <- shp %>%
filter(SubDivisio %in% c("21", "22", "23", "24", "25"))
# 2. Filtra solo le zone desiderate
baltic_mask <- shp %>%
filter(SubDivisio %in% c("21", "22", "23", "24", "25"))
# Trasforma in EPSG:4326
baltic_mask_4326 <- st_transform(baltic_mask, crs = 4326)
# 3. Salva come nuovo shapefile (maschera)
st_write(baltic_mask_4326, "baltic_mask_21_25.shp")
baltic_mask_2 <- shp %>%
filter(SubDivisio %in% c("21", "22", "23", "24", "25", "26"))
# Trasforma in EPSG:4326
baltic_mask_43 <- st_transform(baltic_mask_2, crs = 4326)
# 3. Salva come nuovo shapefile (maschera)
st_write(baltic_mask_43, "baltic_mask_21_26.shp")
baltic_mask3 <- shp %>%
filter(SubDivisio %in% c("21", "22", "23", "24", "25", "26", "27"))
# Trasforma in EPSG:4326
baltic_mask_bb <- st_transform(baltic_mask3, crs = 4326)
# 3. Salva come nuovo shapefile (maschera)
st_write(baltic_mask_bb, "baltic_mask_21_27.shp")
baltic_mask5 <- shp %>%
filter(SubDivisio %in% c("21", "22", "23", "24", "25", "26", "28"))
baltic_mask_cc <- st_transform(baltic_mask5, crs = 4326)
# 3. Salva come nuovo shapefile (maschera)
st_write(baltic_mask_cc, "baltic_mask_21_26_28.shp")
baltic_mask6 <- shp %>%
filter(SubDivisio %in% c("21", "22", "23", "24", "25", "26", "27", "28"))
baltic_mask_dd <- st_transform(baltic_mask6, crs = 4326)
# 3. Salva come nuovo shapefile (maschera)
st_write(baltic_mask_dd, "baltic_mask_21_28.shp")
